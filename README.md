shellsquid
==========

At its core, shellsquid is just a dynamic and configurable http(s) reverse proxy. The intended purpose is to enable teams to share a single Internet facing interface and port when handling multiple reverse payloads ("shells"). The original version of shellsquid used customized payloads to determine routing, and was overly complex. This version uses hostnames and is much more straight forward.

A common way of configuring payload routing is to register a single domain with a wildcard DNS record, and then use subdomains to route payloads.

### Installation and Configuration

#### Installation Requirements
None, shellsquid is written in Go and uses boltdb.

#### Configuration
Configuration is done via a JSON file in `config.json`. The following values are supported:

You will need to generate a certificate and key files separately. Do whatever is best for your needs and environment.

#### Starting the server
`$ ./shellsquid`

### Metasploit Configuration
This version of shellsquid does not require any special handlers! There are still some considerations to make when configuring your multi-handler. The reason for these configurations it to control the `payload_uri` that is generated by the handler, we need that to output the address of our proxy and not the actual handler. Configuration steps:
  * set LHOST to the hostname of your record.
  * set LPORT to the listening port of the proxy. If it's an http(s) payload and your proxy is configured to listen on 443, then set it to 443.
  * use the advanced options of `ReverseListenerBindPort` and `ReverseListenerBindAddress` to set the actual interface and port for the handler to use.
  * run like normal.

### Security
Authentication and authorization is performed using JSON Web Tokens ("JWT"). The administrative portion of the application is configured by default to listen on a separate port and interface than the http and https proxy handler. Access to the administrative interface is done using a username and password. Currently, all users have the same permissions and can change the passwords of other users. This is fully intentional, everyone is an admin. There didn't seem like there was much to be gained by having a finegrained permissions model.

### Development

#### Server
The server is written in Go and uses boltdb. Configuration is done in `config.json`. This project uses godep for dependency management. To start the server:
```
# Install godep
$ go get github.com/tools/godep
# Run the server, all dependencies are managed and stored in the using godep in the Godeps directory
$ sudo -E godep go run main.go
```

#### Client
Client code lives in the `/client` directory. To run it you need to install node.js, bower, and grunt-cli. Once you have node.js installed:

```
$ npm install -g grunt-cli
$ npm install -g bower
```

From the client directory, install the required npm and bower modules

```
$ bower i
$ npm i
```

You can start a server with live reload for the client using grunt. The grunt configuration will send all API requests to the server at https://127.0.0.1:1337.

```
$ grunt serve
```
